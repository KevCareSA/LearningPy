# Python Object-Oriented Programming (OOP)

## 1. **Understanding Object-Oriented Programming (OOP)**

- **What is Object-Oriented Programming (OOP)?**
  - Object-Oriented Programming (OOP) is a programming paradigm that organizes software design around data, or objects, rather than functions and logic. In OOP, everything is represented as objects, which can be instances of classes. These objects encapsulate both data (attributes) and behaviors (methods), making it easier to model real-world entities and relationships in code.
  - **Core Concepts of OOP**:
    - **Classes and Objects**: The fundamental building blocks of OOP.
    - **Encapsulation**: Bundling the data (attributes) and methods that manipulate the data into a single unit or class.
    - **Abstraction**: Hiding the complex reality while exposing only the necessary parts.
    - **Inheritance**: Creating new classes from existing ones, promoting code reuse.
    - **Polymorphism**: Allowing different classes to be treated as instances of the same class through a common interface.
- **Why Use OOP?**
  - **Modularity**: OOP allows you to break down your program into smaller, self-contained units (classes and objects). Each class or object handles a specific aspect of the program, which makes the code more modular and easier to understand, maintain, and debug.
  - **Reusability**: OOP promotes code reuse through inheritance and composition. You can create new classes by extending existing ones, thereby reusing existing code and reducing redundancy.
  - **Encapsulation**: OOP enables you to bundle the data (attributes) and the methods (functions) that operate on the data within a single unit, the class. This protects the integrity of the data by restricting direct access and modification from outside the class.
  - **Abstraction**: OOP allows you to hide complex implementation details and expose only the essential features of an object. This makes your code easier to work with and less error-prone.
  - **Polymorphism**: OOP provides the ability to define methods in a base class and override them in derived classes. This allows objects of different classes to be treated as objects of a common base class, simplifying code and reducing coupling.

### 2. **Classes and Objects: The Foundation of OOP**

- **What is a Class?**
  - A class is a blueprint for creating objects. It defines a set of attributes (data) and methods (functions) that the objects created from the class will have. Think of a class as a template or a blueprint for objects. For example, you might have a `Car` class that defines the attributes like `color`, `make`, and `model`, and methods like `drive()` and `brake()`.
  - **Class Syntax**:
    - The syntax for defining a class in Python is as follows:

            ```python
            class ClassName:
                # Class attributes and methods go here
            
            ```

    - Example:

            ```python
            class Car:
                pass  # Placeholder for future code
            
            ```

    - The `pass` keyword is used as a placeholder when you don't want to define any attributes or methods yet.
- **What is an Object?**
  - An object is an instance of a class. Once you have a class defined, you can create objects (also called instances) from that class. Each object is an independent entity with its own state (attribute values) and behavior (methods).
  - **Object Syntax**:
    - To create an object from a class, you use the following syntax:

            ```python
            object_name = ClassName()
            
            ```

    - Example:

            ```python
            my_car = Car()
            
            ```

    - Here, `my_car` is an object (instance) of the `Car` class.
- **Class Attributes and Instance Attributes**:
  - **Class Attributes**: Attributes that are shared by all instances of a class. These are defined directly within the class and are accessed using the class name.
    - Example:

            ```python
            class Car:
                wheels = 4  # Class attribute
            
            print(Car.wheels)  # Outputs: 4
            
            ```

  - **Instance Attributes**: Attributes that are specific to each object (instance) of a class. These are usually defined within the `__init__()` method, which is a special method used for initializing newly created objects.
    - Example:

            ```python
            class Car:
                def __init__(self, color, make, model):
                    self.color = color  # Instance attribute
                    self.make = make    # Instance attribute
                    self.model = model  # Instance attribute
            
            my_car = Car("Red", "Toyota", "Camry")
            print(my_car.color)  # Outputs: Red
            
            ```

- **Methods: Functions Inside a Class**:
  - Methods are functions defined inside a class that operate on the attributes of the class. The first parameter of a method is always `self`, which refers to the instance calling the method.
  - **Example**:

        ```python
        class Car:
            def __init__(self, color, make, model):
                self.color = color
                self.make = make
                self.model = model
        
            def drive(self):
                print(f"The {self.color} {self.make} {self.model} is driving.")
        
        my_car = Car("Red", "Toyota", "Camry")
        my_car.drive()  # Outputs: The Red Toyota Camry is driving.
        
        ```

### 3. **Encapsulation: Protecting Data**

- **What is Encapsulation?**
  - Encapsulation is the concept of bundling data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. It also involves restricting access to certain parts of an object’s data, making it harder to modify the data accidentally or maliciously.
  - In Python, encapsulation is achieved by defining attributes and methods within a class and controlling access using access modifiers.
- **Access Modifiers**:
  - **Public**: Attributes and methods that are accessible from outside the class. In Python, all attributes and methods are public by default.
  - **Private**: Attributes and methods that are accessible only within the class itself. In Python, private attributes and methods are indicated by a double underscore prefix (`__`).
  - **Protected**: Attributes and methods that are accessible within the class and by subclasses. In Python, protected attributes and methods are indicated by a single underscore prefix (`_`).
  - **Example**:

        ```python
        class Car:
            def __init__(self, make, model, year):
                self.make = make          # Public attribute
                self._model = model       # Protected attribute
                self.__year = year        # Private attribute
        
            def get_year(self):
                return self.__year  # Public method to access private attribute
        
        my_car = Car("Toyota", "Camry", 2020)
        print(my_car.make)        # Outputs: Toyota
        print(my_car._model)      # Outputs: Camry
        print(my_car.get_year())  # Outputs: 2020
        print(my_car.__year)      # Raises AttributeError
        
        ```

  - In this example, `make` is public, `_model` is protected, and `__year` is private. Private attributes like `__year` cannot be accessed directly from outside the class but can be accessed through a public method like `get_year()`.
- **Why Use Encapsulation?**
  - Encapsulation helps protect the internal state of an object and prevents external code from altering it in unintended ways. It also provides a clear interface for interacting with the object's data, making your code more robust and maintainable.

### 4. **Inheritance: Reusing Code**

- **What is Inheritance?**
  - Inheritance is a mechanism that allows you to create a new class (child class) that inherits attributes and methods from an existing class (parent class). The child class can add its own attributes and methods, or override the inherited ones. Inheritance promotes code reuse and establishes a natural hierarchy between classes.
  - **Syntax**:
    - The syntax for inheritance in Python is as follows:

            ```python
            class ParentClass:
                # Parent class code
            
            class ChildClass(ParentClass):
                # Child class code
            
            ```

    - Example:

            ```python
            class Vehicle:
                def __init__(self, make, model):
                    self.make = make
                    self.model = model
            
                def start(self):
                    print(f"The {self.make} {self.model} is starting.")
            
            class Car(Vehicle):  # Car inherits from Vehicle
                def drive(self):
                    print(f"The {self.make} {self.model} is driving.")
            
            my_car = Car("Toyota", "Camry")
            my_car.start()  # Inherited method: Outputs: The Toyota Camry is starting.
            my_car.drive()  # Child class method: Outputs: The Toyota Camry is driving.
            
            ```

- **Method Overriding**:
  - In a child class, you can override (redefine) a method inherited from the parent class. This allows the child class to provide a specific implementation of the method.
  - **Example**:

        ```python
        class Vehicle:
            def start(self):
                print("The vehicle is starting.")
        
        class Car(Vehicle):
            def start(self):
                print("The car is starting.")  # Overriding the start method
        
        my_car = Car()
        my_car.start()  # Outputs: The car is starting.
        
        ```

-

**The `super()` Function**:

- The `super()` function in Python is used to call a method from the parent class inside a child class. This is particularly useful when you want to extend the functionality of an inherited method without completely overriding it.
- **Example**:

```python
class Vehicle:
def start(self):
print("The vehicle is starting.")

```

   class Car(Vehicle):
       def start(self):
           super().start()  # Call the parent class method
           print("The car is ready to go.")

   my_car = Car()
   my_car.start()

### Outputs

### The vehicle is starting

### The car is ready to go

```


```

- **Why Use Inheritance?**
  - Inheritance allows you to create a hierarchical relationship between classes, promote code reuse, and make your programs more modular and easier to maintain.

### 5. **Polymorphism: Flexibility in Code**

- **What is Polymorphism?**
  - Polymorphism is the ability of different classes to respond to the same method name in different ways. In Python, polymorphism is achieved through method overriding and method overloading (though true overloading is not supported in Python, but achieved in a different way).
  - **Method Overriding**: When a method in a child class has the same name as a method in the parent class, but a different implementation.
  - **Method Overloading**: Python does not support traditional method overloading, but you can achieve similar behavior by using default parameters or by checking the types and number of arguments inside a method.
- **Example of Polymorphism**:

```python
    class Animal:
        def speak(self):
            pass
    
    class Dog(Animal):
        def speak(self):
            return "Woof!"
    
    class Cat(Animal):
        def speak(self):
            return "Meow!"
    
    animals = [Dog(), Cat()]
    
    for animal in animals:
        print(animal.speak())
    # Outputs:
    # Woof!
    # Meow!
    
    ```

  - In this example, both `Dog` and `Cat` classes inherit from the `Animal` class, but they each implement the `speak()` method differently. The loop demonstrates polymorphism by calling the `speak()` method on each animal without knowing the exact type of the object.
    - **Why Use Polymorphism?**
  - Polymorphism allows you to write more flexible and reusable code. You can design functions and methods to operate on objects of different types, provided they follow a common interface (e.g., having the same method names).

### 6. **Abstraction: Simplifying Complex Reality**

- **What is Abstraction?**
  - Abstraction is the concept of hiding the complex implementation details of a system and exposing only the necessary and relevant parts to the user. In Python, abstraction is typically achieved using abstract base classes (ABCs) and interfaces (although Python does not have a built-in interface keyword, you can create them using ABCs).
- **Abstract Base Classes (ABCs)**:
  - An abstract base class is a class that cannot be instantiated and is meant to be subclassed. It can contain abstract methods, which are methods that are declared but contain no implementation. Subclasses must override and provide an implementation for these abstract methods.
  - **Example**:

        ```python
        from abc import ABC, abstractmethod
        
        class Animal(ABC):
            @abstractmethod
            def speak(self):
                pass
        
        class Dog(Animal):
            def speak(self):
                return "Woof!"
        
        class Cat(Animal):
            def speak(self):
                return "Meow!"
        
        dog = Dog()
        cat = Cat()
        print(dog.speak())  # Outputs: Woof!
        print(cat.speak())  # Outputs: Meow!
        
        ```

  - In this example, `Animal` is an abstract base class with an abstract method `speak()`. The `Dog` and `Cat` classes must implement the `speak()` method.
- **Why Use Abstraction?**
  - Abstraction allows you to manage complexity by breaking down large systems into simpler, more manageable components. It also provides a way to define a common interface for different implementations, which can be particularly useful in large-scale systems.

### 7. **Comprehensive Example: A Python OOP Project**

- **Project Overview**:
  - Let's build a simple library management system using the principles of OOP. The system will have classes like `Library`, `Book`, and `Member`.
- **Step-by-Step Implementation**:
  - **Step 1: Define the `Book` Class**:

        ```python
        class Book:
            def __init__(self, title, author, isbn):
                self.title = title
                self.author = author
                self.isbn = isbn
        
            def __str__(self):
                return f"{self.title} by {self.author} (ISBN: {self.isbn})"
        
        ```

  - **Step 2: Define the `Member` Class**:

        ```python
        class Member:
            def __init__(self, name, member_id):
                self.name = name
                self.member_id = member_id
                self.borrowed_books = []
        
            def borrow_book(self, book):
                self.borrowed_books.append(book)
        
            def return_book(self, book):
                self.borrowed_books.remove(book)
        
            def __str__(self):
                return f"Member: {self.name} (ID: {self.member_id})"
        
        ```

  - **Step 3: Define the `Library` Class**:

        ```python
        class Library:
            def __init__(self):
                self.books = []
                self.members = []
        
            def add_book(self, book):
                self.books.append(book)
        
            def remove_book(self, book):
                self.books.remove(book)
        
            def add_member(self, member):
                self.members.append(member)
        
            def remove_member(self, member):
                self.members.remove(member)
        
            def __str__(self):
                return f"Library with {len(self.books)} books and {len(self.members)} members"
        
        ```

  - **Step 4: Demonstrate the System**:

        ```python
        # Create a library
        library = Library()
        
        # Add books to the library
        book1 = Book("The Great Gatsby", "F. Scott Fitzgerald", "9780743273565")
        book2 = Book("1984", "George Orwell", "9780451524935")
        library.add_book(book1)
        library.add_book(book2)
        
        # Add a member to the library
        member = Member("Alice", "M001")
        library.add_member(member)
        
        # Borrow a book
        member.borrow_book(book1)
        
        # Print the current state of the library and the member
        print(library)  # Outputs: Library with 2 books and 1 members
        print(member)   # Outputs: Member: Alice (ID: M001)
        
        ```

- **Explanation**:
  - **Book Class**: Represents a book with attributes for title, author, and ISBN. It also includes a `__str__` method for string representation.
  - **Member Class**: Represents a library member with a name, member ID, and a list of borrowed books. It includes methods for borrowing and returning books.
  - **Library Class**: Represents a library with a collection of books and members. It includes methods for adding and removing books and members.
  - **System Demonstration**: The demonstration shows how to create a library, add books and members, borrow books, and print the current state of the library and its members.

### Conclusion

This guide provides a comprehensive overview of Python's Object-Oriented Programming (OOP) principles, with detailed explanations, examples, and a practical project to tie everything together. By mastering these concepts, you will be well-equipped to design and build complex, scalable, and maintainable software systems in Python.

OOP is a way of organizing your code to make it more understandable and reusable by mimicking how things work in the real world.

Example of how OOP would work:

Restaurant with a manager that manages the chef, the waiter and the cleaner.  

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a91443e-616b-43e4-b0b7-3012a6086b57/66ecf0f8-5a78-4f13-a059-abe419cdfdc6/Untitled.png)

If we are about to model the waiter, we need to take 2 things into consideration:
    What it **has:**  (attributes)
   **** What it does: (methods)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a91443e-616b-43e4-b0b7-3012a6086b57/3463949a-1911-4cf2-b2fc-f6964407ef35/Untitled.png)

OOP Concept In Python:

Class

Object

Abstraction

Encapsulation

Inheritance

Polymorphism

%%%%%%%%%%%%%%%%%%%%%%%%%

## -**Class**

- The blueprint/Template which is followed by objects (Class can create multiple objects)
- Logical structure with behaviour
- The process of creating an object from the class is called **instantiation**

There are two stages when using classes:

 1. The first stage is the class definition.

```python
# creating your first class
class Car( ):
pass #
```

1. The second stage is called instantiation.

    ```python
    # instantiating an object from a class
    class Car(): 
     pass
    
    ford = Car() #creates an instance of the Car class and stores into the variable ford
    ```

## -**Objects**

- Objects are instances of a class.
- They represent individual entities with their own unique characteristics and behaviours.
- Example: A specific car object with its own color, model, and speed.

### **Creating Multiple Instances/Objects**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a91443e-616b-43e4-b0b7-3012a6086b57/a3c5ccb6-c6bb-4326-8dc7-247920bd66cc/Untitled.png)

- You can create as many instances as you want from each class; however,
you store them in separate variables or data collections.

    ```python
    # instantiating multiple objects from the same class
    class Car( ):
     pass
    
    ford = Car( )
    subaru = Car( ) # creates another object from the car class
    ```

- After creating classes and objects/instances, we have to personalize and create features of those objects/instances also known as **Attributes.**

        -Attributes are just variables defined within a class

```python
    # how to define a class attribute
    class Car( ):
     sound = "beep"  # all car objects will have this sound attribute and its' value
     color = "red"   # all car objects will have this color attribute and its' value
    
    ford = Car()
    print(ford.color) # known as 'dot syntax'
    ```

### Using the **init**( ) Method

- When you want to create an object from class with specific properties, you need to use the initialization (init) method.
- The declaration for this method has two underscores before and after the word init. (**init**)

    It also includes the “self” keyword inside of the parenthesis as a mandatory parameter.

```python
    # using the init method to give instances personalized attributes upon creation
    class Car( ):
     def __init__(self, color):
      self.color = color # sets the attribute color to the value passed in
    
    ford = Car("blue") # instantiating a Car class with the color blue
    print(ford.color)
    ```

### The “self” Keyword

- The **self** keyword represents the current object of the class
and is used to access variables and methods associated with that object.

### Instantiating Multiple Objects with **init**( )

-

```python
# defining different values for multiple instances
class Car( ):
 def __init__(self, color, year):
 self.color = color # sets the attribute color to the value passed in
 self.year = year

ford = Car("blue", 2016) # create a car object with the color blue and year 2016
subaru = Car("red", 2018) # create a car object with the color red and year 2018
print(ford.color, ford.year)
print(subaru.color, subaru.year)
```

## -Methods

- Methods are essentially functions that are within classes.
- Defining and Calling a Method:

```python
# defining and calling our first class method

# Define a class named Dog
class Dog():
    # Define a method within the Dog class named makeSound
    def makeSound(self):
        # Print the string "bark" when makeSound is called
        print("bark")

# Create an instance of the Dog class and assign it to the variable sam
sam = Dog()

# Call the makeSound method on the sam object (instance of Dog)
sam.makeSound()
```

1. **Class Definition (class Dog():):**
   - `class Dog():` declares a class named `Dog`. Classes are used to define the
  structure and behavior of objects.

2. **Method Definition (`def makeSound(self):`):**
   - `def makeSound(self):` defines a method named `makeSound` within the `Dog` class.
  The `self` parameter refers to the instance of the class, allowing access to its
  attributes and other methods.

3. **Print Statement (`print("bark")`):**
   - The `print("bark")` statement inside the `makeSound` method prints the string "bark"
  to the console when the method is called.

4. **Object Instantiation (`sam = Dog()`):**
   - `sam = Dog()` creates an instance of the `Dog` class and assigns it to the variable
  `sam`. This instance represents an individual dog object.

```python
# Call the makeSound method on the sam object (instance of Dog)
sam.makeSound()
```

5. **Method Invocation (`sam.makeSound()`):**
   - `sam.makeSound()` calls the `makeSound` method on the `sam` object. This triggers
   the execution of the `print("bark")` statement within the `makeSound` method.

The result of running this code would be the output:

```
    bark
```

This is because the `makeSound` method is invoked on the `sam` object, leading to
the printing of "bark" to the console.

```

## Accessing Class Attributes in Methods

```python
# using the self keyword to access attributes within class methods
class Dog( ):
 sound = "bark"    # Class variable 'sound' shared by all instances of the class

# Object method 'makeSound' which prints the 'sound' variable of the instance
 def makeSound(self):   
 print(self.sound) # self required to access attributes defined in the class

sam = Dog( )
sam.makeSound( )
```

1. **Class Definition (`class Dog():`):**
    - `class Dog():` declares a class named `Dog`. In Python, classes are used to create objects, and objects can have attributes (data) and methods (functions).
2. **Method Definition (`def makeSound(self):`):**
    - `def makeSound(self):` defines a method named `makeSound` within the `Dog` class. This method takes one parameter, `self`, which refers to the instance of the class. In this case, `makeSound` is a simple method that prints the string "bark."
3. **Print Statement (`print("bark")`):**
    - The `print("bark")` statement inside the `makeSound` method is responsible for displaying the word "bark" on the console when the method is called.
4. **Object Instantiation (`sam = Dog()`):**
    - `sam = Dog()` creates an instance of the `Dog` class and assigns it to the variable `sam`. This is known as object instantiation. Now, `sam` is an object of the `Dog` class.

```python
# Call the makeSound method on the sam object (instance of Dog)
sam.makeSound( )

```

1. **Method Invocation (`sam.makeSound()`):**
    - `sam.makeSound()` calls the `makeSound` method on the `sam` object. This results in the execution of the `print("bark")` statement within the `makeSound` method, and the output "bark" is displayed on the console.

In summary, the code demonstrates the creation of a simple class (`Dog`) with a method (`makeSound`) that, when invoked on an instance of the class (`sam`), prints the word "bark" to the console.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a91443e-616b-43e4-b0b7-3012a6086b57/2c1e4cdd-e298-4f5a-91ec-1a401cf07a4f/Untitled.png)

## Passing Arguments into Methods

- Methods work the same way as functions, where you can pass arguments into the
method to be used.
- When these arguments are passed in, they do not need to be referenced with the self parameter, as they are not attributes, but rather temporary
variables that the method can use:

    ```python
    # writing methods that accept parameters
    
    class Dog():
        # Define a method named 'showAge' within the Dog class
        def showAge(self, age):
            print(age)  # does not need self, age is referencing the parameter,not an attribute
    
    sam = Dog()
    
    # Call the 'showAge' method on the 'sam' object and pass the integer 6 as an argument
    sam.showAge(6)  # passing the integer 6 as an argument to the showAge method
    ```

1. **Class Definition (`class Dog():`):**
    - `class Dog():` declares a class named `Dog`. Classes in Python are used to define the structure and behavior of objects.
2. **Method Definition (`def showAge(self, age):`):**
    - `def showAge(self, age):` defines a method named 'showAge' within the `Dog` class. This method takes two parameters: `self` (a reference to the instance of the class) and `age` (a parameter representing the age of the dog).
3. **Print Statement (`print(age)`):**
    - `print(age)` is a statement inside the `showAge` method that prints the value of the `age` parameter. It's worth noting that 'age' here is a local variable within the method and is not an attribute of the class.
4. **Object Instantiation (`sam = Dog()`):**
    - `sam = Dog()` creates an instance of the `Dog` class and assigns it to the variable `sam`. Now, `sam` is an object of the `Dog` class.
5. **Method Invocation with Argument (`sam.showAge(6)`):**
    - `sam.showAge(6)` calls the `showAge` method on the `sam` object. The argument `6` is passed to the `age` parameter of the method. The method then prints the value of the `age` parameter, which is 6 in this case.

In summary, this code demonstrates the creation of a class (`Dog`) with a method (`showAge`) that accepts a parameter (`age`). An instance of the class (`sam`) is created, and the `showAge` method is called on that instance with the argument `6`. The method prints the value of the passed argument.

## Using Setters and Getters

In Python, setters and getters are methods used to access and modify the attributes of a class. They are part of a concept called **Encapsulation**, which involves controlling the access to the internal state of an object.

- **Getter:** A getter is a method that allows you to retrieve the value of a private attribute (a variable within a class). It provides access to the value without directly exposing the attribute.
- **Setter:** A setter is a method that allows you to modify the value of a private attribute. It provides a way to update the internal state of the object while potentially applying some logic or validation.

```python
# Step 1: Class Definition
class MyClass:
    # Step 2: Constructor (Initializer)
    def __init__(self, my_variable):
        # Step 3: Attribute Initialization
        self._my_variable = my_variable

    # Step 4: Getter Method
    def get_my_variable(self):
        return self._my_variable

    # Step 5: Setter Method
    def set_my_variable(self, new_value):
        # Step 6: Setter Logic/Validation
        if new_value > 0:
            self._my_variable = new_value

# Step 7: Object Creation
obj = MyClass(42)

# Step 8: Getter Usage
value = obj.get_my_variable()
print("Initial Value:", value)

# Step 9: Setter Usage
obj.set_my_variable(50)
print("Updated Value:", obj.get_my_variable())

# Step 10: Attempting Invalid Setter Usage
obj.set_my_variable(-5)

# Step 11: Getter Usage After Invalid Setter
print("Value After Invalid Setter:", obj.get_my_variable())

```

Explanation:

1. **Class Definition (`class MyClass`):**
    - We define a class named `MyClass` to encapsulate functionality.
2. **Constructor (`def __init__(self, my_variable):`):**
The class has a constructor that takes an initial value (`my_variable`) and initializes the `_my_variable` attribute with this value.
3. **Attribute Initialization (`self._my_variable = my_variable`):**
Inside the constructor, the attribute `_my_variable` is initialized with the value provided during object creation.
4. **Getter Method (`def get_my_variable(self):`):**
We define a method `get_my_variable` that allows us to retrieve the value of the `_my_variable` attribute.
5. **Setter Method (`def set_my_variable(self, new_value):`):**
We define a method `set_my_variable` that allows us to update the value of the `_my_variable` attribute. It includes a validation check to ensure that the new value is greater than 0.
6. **Setter Logic/Validation (`if new_value > 0:`):**
Inside the setter method, there is a validation check. If the new value is greater than 0, the `_my_variable` attribute is updated; otherwise, it remains unchanged.
7. **Object Creation (`obj = MyClass(42)`):**
We create an instance of the `MyClass` class, providing an initial value of `42`.
8. **Getter Usage (`value = obj.get_my_variable()`):**
We use the getter method to retrieve the initial value of the `_my_variable` attribute and store it in the variable `value`.
9. **Setter Usage (`obj.set_my_variable(50)`):**
We use the setter method to update the value of the `_my_variable` attribute to `50`.
10. **Attempting Invalid Setter Usage (`obj.set_my_variable(-5)`):**
We attempt to use the setter with an invalid value (`5`), which should not pass the validation check.
11. **Getter Usage After Invalid Setter (`print("Value After Invalid Setter:", obj.get_my_variable())`):**
We use the getter method again to retrieve and print the current value of the `_my_variable` attribute after the invalid setter usage. The value should remain unchanged.

### Another Example Of Setters And Getters

```python
# Step 1: Class definition for Dog
class Dog:
    # Step 2: Class attribute 'name' with an initial value of an empty string
    name = ' '  # Note: Would normally use the __init__ method for attribute initialization; this is for testing purposes

    # Step 3: Method to set the 'name' attribute with a new value
    def setName(self, new_name):
        # Step 4: Setting the 'name' attribute
        self.name = new_name  # Declares the new value for the 'name' attribute

    # Step 5: Method to get (return) the current value of the 'name' attribute
    def getName(self):
        # Step 6: Returning the 'name' attribute value
        return self.name  # Returns the value of the 'name' attribute

# Step 7: Creating an instance of the Dog class
sam = Dog()

# Step 8: Calling the setName method to set the 'name' attribute of the 'sam' object
sam.setName("Sammi")

# Step 9: Printing the returned value of the getName method, which retrieves the 'name' attribute
print(sam.getName())  # Output: Sammi

```

Explanation with grouped steps:

1. **Class Definition (`class Dog`):**
    - Defines a class named `Dog`.
2. **Class Attribute (`name = ' '`):**
    - Declares a class attribute `name` with an initial value of an empty string. Note that in practice, the `__init__` method is typically used for attribute initialization.
3. **Setter Method (`def setName(self, new_name):`):**
    - Defines a method `setName` within the class, which takes a parameter `new_name`. This method is used to set the value of the `name` attribute.
4. **Setting Attribute (`self.name = new_name`):**
    - Inside the `setName` method, assigns the `new_name` parameter to the `name` attribute of the object using `self`.
5. **Getter Method (`def getName(self):`):**
    - Defines a method `getName` within the class. This method is used to retrieve (get) the current value of the `name` attribute.
6. **Returning Attribute (`return self.name`):**
    - Inside the `getName` method, returns the current value of the `name` attribute.
7. **Object Creation (`sam = Dog()`):**
    - Creates an instance of the `Dog` class named `sam`.
8. **Setting Attribute (`sam.setName("Sammi")`):**
    - Calls the `setName` method on the `sam` object to set the `name` attribute to "Sammi".
9. **Getting and Printing Attribute (`print(sam.getName())`):**
    - Calls the `getName` method on the `sam` object to retrieve the current value of the `name` attribute and prints it. The output should be "Sammi".

### Inheritance

-

Inheritance is a concept in object-oriented programming where a class can inherit the properties and methods of another class. It allows us to create a hierarchy of classes, where the child class inherits the characteristics of the parent class.

When you have two or more classes that use similar code, you generally
want to set up what is called a “superclass.” The two classes that will inherit all the code
within the superclass are known as “subclasses.”

The child class can access and use the attributes and methods of the parent class, and it can also add its own unique attributes and methods. This helps in code reusability and allows us to create specialized classes based on existing ones.

To illustrate the concept of inheritance. In this example, we'll create a superclass called `Animal` and two subclasses, `Dog` and `Cat`, which inherit from the `Animal` superclass.

```python
# Step 1: Define the Animal superclass
class Animal:
    # Step 2: Constructor for the Animal class, initializes the 'species' attribute
    def __init__(self, species):
        self.species = species

    # Step 3: Method for the Animal class, a placeholder to be overridden by subclasses
    def make_sound(self):
        pass  # This method will be overridden by subclasses, serves as a placeholder

# Step 4: Create a Dog subclass inheriting from Animal
class Dog(Animal):
    # Step 5: Constructor for the Dog class, calling the superclass constructor
    def __init__(self, breed):
        
  # Step 6: # Call superclass constructor with species="Dog" and initialize Dog-specific attribute 'breed'
        super().__init__(species="Dog")
        self.breed = breed        

    # Step 7: Method for the Dog class, overrides the parent class method
    def make_sound(self):
        return "Woof!"  # Overrides the make_sound method from the Animal class

# Step 8: Create a Cat subclass inheriting from Animal
class Cat(Animal):
    # Step 9: Constructor for the Cat class, calling the superclass constructor
    def __init__(self, color):
        # Step 10: Call the superclass constructor with the 'species' attribute set to "Cat"
        super().__init__(species="Cat")
        self.color = color

    # Step 11: Method for the Cat class, overrides the parent class method
    def make_sound(self):
        return "Meow!"  # Overrides the make_sound method from the Animal class

# Step 12: Create instances of the subclasses
dog_instance = Dog(breed="Golden Retriever")
cat_instance = Cat(color="Calico")

# Step 13: Access attributes and methods of the instances
print(f"{dog_instance.species} of breed {dog_instance.breed} says: {dog_instance.make_sound()}")
print(f"{cat_instance.species} of color {cat_instance.color} says: {cat_instance.make_sound()}")
```

Explanation with code comments:

1. **Define the Animal superclass (`class Animal`):**
    - The superclass has an `__init__` method to initialize the `species` attribute.
    - It also has a placeholder method `make_sound` to be overridden by subclasses.
2. **Create a Dog subclass inheriting from Animal (`class Dog(Animal)`):**
    - The `Dog` subclass inherits from the `Animal` superclass.
    - It has its own `__init__` method, calling the superclass constructor and initializing the `breed` attribute.
    - It overrides the `make_sound` method to return "Woof!".
3. **Create a Cat subclass inheriting from Animal (`class Cat(Animal)`):**
    - The `Cat` subclass inherits from the `Animal` superclass.
    - It has its own `__init__` method, calling the superclass constructor and initializing the `color` attribute.
    - It overrides the `make_sound` method to return "Meow!".
4. **Create instances of the subclasses (`dog_instance`, `cat_instance`):**
    - Instances of `Dog` and `Cat` are created with specific attributes.
5. **Access attributes and methods of the instances:**
    - Print statements demonstrate how to access the attributes (`species`, `breed`, `color`) and call the overridden `make_sound` method for each instance.

This example showcases how a superclass (`Animal`) provides a common structure, and subclasses (`Dog`, `Cat`) inherit and extend that structure with specific attributes and methods. It promotes code reusability and organization.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/5a91443e-616b-43e4-b0b7-3012a6086b57/288a5a79-f16a-4387-b760-4c645c85b6d6/Untitled.png)

## Inheriting Multiple Classes

- Thus far, we’ve seen how we can inherit from a single superclass. Now we’re going to try
inheriting from multiple classes. The main difference is how you super the attributes.
Rather than using the super method, you call the class name directly and pass in the self
parameter with the attributes. Let’s see how:

```python
# Defining the superclass Physics
class Physics( ):
    gravity = 9.8

# Explanation:
# - Defines a superclass named Physics.
# - Contains a class attribute gravity set to 9.8.

# Defining the superclass Automobile
class Automobile( ):
    def __init__(self, make, model, year):
        # Declaring all attributes on one line
        self.make, self.model, self.year = make, model, year

# Explanation:
# - Defines a superclass named Automobile.
# - Contains a constructor (__init__) that initializes attributes make, model, and year.

# Defining the subclass Ford, inheriting from Physics and Automobile
class Ford(Physics, Automobile):  # Subclass able to access attributes and methods from both Physics and Automobile
    def __init__(self, model, year):
        # Using Automobile's constructor to initialize make, model, and year
        Automobile.__init__(self, "Ford", model, year)  # Super does not work with multiple inheritance

# Creating an instance of the subclass Ford
truck = Ford("F-150", 2018)

# Accessing attributes from both Physics (superclass) and Automobile (superclass) in the Ford (subclass) instance
print(truck.gravity, truck.make)  # Output both attributes
```

Expansion:

- **Physics Class:**
  - `Physics` class defines a class attribute `gravity` set to 9.8, representing the gravitational acceleration.
- **Automobile Class:**
  - `Automobile` class includes a constructor (`__init__`) that initializes attributes `make`, `model`, and `year` for a generic automobile.
- **Ford Class (Multiple Inheritance):**
  - `Ford` class inherits from both `Physics` and `Automobile`, showcasing multiple inheritance.
  - It has its own constructor that utilizes the `__init__` method of the `Automobile` class to initialize make, model, and year.
- **Creating an Instance:**
  - An instance named `truck` is created using the `Ford` class with specific parameters for model ("F-150") and year (2018).
- **Accessing Attributes:**
  - The `print` statement demonstrates the ability to access attributes from both the `Physics` and `Automobile` classes in the `Ford` instance.
  - It outputs the gravity attribute (from `Physics`) and the make attribute (from `Automobile`).
